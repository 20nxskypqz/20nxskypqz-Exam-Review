<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>20nxskypqz Exam Review</title>

  <!-- Google Font: Niramit -->
  <link href="https://fonts.googleapis.com/css2?family=Niramit:wght@400;700&display=swap" rel="stylesheet">

  <style>
    :root { --bg:#f9f9f9; --card:#fff; --shadow:0 6px 24px rgba(0,0,0,.08); }
    * { box-sizing:border-box; }
    body {
      margin:0; background:var(--bg); color:#111; font-family:'Niramit',system-ui,-apple-system,Segoe UI,Arial,sans-serif;
      line-height:1.8; padding:20px;
    }
    h1,h2 { text-align:center; margin:0 0 10px 0; font-weight:700; }
    .docTitle { text-align:center; font-weight:700; margin:16px auto 8px; font-size:22px; }
    #content {
      max-width: 960px; margin: 12px auto 24px; background:var(--card); border-radius:12px; box-shadow:var(--shadow);
      padding: 20px; white-space: normal; /* เราจะจัดบรรทัดเองด้วย <div.line> */
      font-size:18px;
    }
    .line { display:block; }          /* 1 บรรทัดใน PDF = 1 บรรทัดจริง */
    .chunk { display:inline; }        /* ชิ้นข้อความภายในบรรทัด */
    .bold { font-weight:700 !important; }
    .italic { font-style:italic; }
    .error { color:#c00; text-align:center; font-weight:700; margin-top:16px; }
    .divider { height:12px; }         /* เว้นเล็กน้อยระหว่างหน้า แต่ไม่ขึ้นหน้าใหม่ */
  </style>
</head>
<body>
  <h1>Welcome to</h1>
  <h2>20nxskypqz Exam Review</h2>
  <div class="docTitle">สังคมศึกษา ม.4_1-68</div>

  <div id="content">Loading text from PDF...</div>

  <script type="module">
    import * as pdfjsLib from 'https://unpkg.com/pdfjs-dist@4.4.168/build/pdf.mjs';
    import 'https://unpkg.com/pdfjs-dist@4.4.168/build/pdf.worker.mjs';

    // ====== ตั้งค่าไฟล์และเกณฑ์ ======
    const PDF_PATH = 'files/สังคมศึกษาทุกเรื่องม.4_1-68.pdf';

    // tolerance สำหรับจับ "อยู่บรรทัดเดียวกัน" (หน่วยพิกัด PDF)
    const Y_TOLERANCE = 3.0;

    // เกณฑ์ให้หัวข้อหนาอัตโนมัติ
    const AUTO_BOLD_1 = 25;
    const AUTO_BOLD_2 = 20;

    const contentEl = document.getElementById('content');

    // HTML escape
    const esc = s => s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');

    // ตรวจจับ bold/italic จากชื่อฟอนต์และ family (ครอบคลุม Sarabun/Saraban/PSK/New)
    const BOLD_HINTS_RE = /(bold|black|heavy|demi|semi[-\s]?bold|semibold|demibold|db|bd|700|800|900)/i;
    const ITALIC_HINTS_RE = /(italic|oblique|it|slanted)/i;
    const SARABUN_FAMILY_RE = /(sarabun|saraban|thsarabun|sarabunpsk)/i;

    function isBoldFromName(fontName='', fontFamily='') {
      return BOLD_HINTS_RE.test(fontName) || BOLD_HINTS_RE.test(fontFamily);
    }
    function isItalicFromName(fontName='', fontFamily='') {
      return ITALIC_HINTS_RE.test(fontName) || ITALIC_HINTS_RE.test(fontFamily);
    }

    // จัดกลุ่ม items ตามแกน Y เป็นบรรทัด
    function groupItemsIntoLines(items) {
      const lines = [];
      const used = new Array(items.length).fill(false);

      const it = items.map((item, idx) => {
        const t = item.transform || [1,0,0,1,0,0];
        const fs = Math.max(Math.abs(t[0]||0), Math.abs(t[3]||0)) || 18;
        const x = t[4] || 0;
        const y = t[5] || 0;
        const w = item.width || 0;
        return { idx, item, x, y, w, fontSize: fs };
      });

      // เรียงจากบนลงล่าง
      it.sort((a,b) => b.y - a.y);

      for (let i=0;i<it.length;i++){
        if (used[i]) continue;
        const base = it[i];
        used[i] = true;
        const line = [base];

        for (let j=i+1;j<it.length;j++){
          if (used[j]) continue;
          const cand = it[j];
          if (Math.abs(cand.y - base.y) <= Y_TOLERANCE) {
            used[j] = true;
            line.push(cand);
          }
        }

        // ซ้าย→ขวา
        line.sort((a,b) => a.x - b.x);
        lines.push(line);
      }

      // บน→ล่าง
      lines.sort((A,B)=>B[0].y - A[0].y);
      return lines;
    }

    // ช่องว่างระหว่างชิ้นข้อความ (คำนวณจากช่องว่างจริง)
    function needsSpace(prev, curr) {
      if (!prev) return false;
      const prevEndX = prev.x + (prev.w || 0);
      const gap = curr.x - prevEndX;
      const threshold = Math.max(2, prev.fontSize * 0.25);
      return gap > threshold;
    }

    // บังคับเว้นวรรคกรณีพิเศษ:
    //  - "•" ต้องมีช่องว่างตามหลัง
    //  - "1." "2." "10." ฯลฯ ต้องมีช่องว่างตามหลัง
    function forceTrailingSpaceIfListToken(text) {
      if (text === '•') return true;
      if (/^\d+\.$/.test(text)) return true;
      return false;
    }

    async function renderTextContinuous(url) {
      try {
        const pdf = await pdfjsLib.getDocument(url).promise;
        contentEl.innerHTML = '';

        for (let p=1; p<=pdf.numPages; p++){
          const page = await pdf.getPage(p);
          const textContent = await page.getTextContent();

          const styles = textContent.styles || {}; // ใช้เพื่อเช็ค fontFamily
          // (optional) debug: ดูว่ามีฟอนต์อะไรบ้าง
          // console.log('Styles keys:', Object.keys(styles));
          // Object.entries(styles).forEach(([k,v]) => console.log(k, v.fontFamily));

          if (!textContent.items || textContent.items.length === 0) {
            continue; // หน้านี้อาจเป็นภาพล้วน
          }

          const lines = groupItemsIntoLines(textContent.items);

          for (const line of lines){
            const lineEl = document.createElement('div');
            lineEl.className = 'line';

            let prev = null;
            for (let k=0;k<line.length;k++){
              const seg = line[k];
              const { item, fontSize, x, y, w } = seg;
              const raw = (item.str || '').trim();
              if (!raw) { prev = seg; continue; }

              const span = document.createElement('span');
              span.className = 'chunk';
              span.style.fontSize = `${fontSize}px`;

              const fontName = item.fontName || '';
              const fontFamily = styles[fontName]?.fontFamily || '';

              // 1) หนา/เอียงจากข้อมูลฟอนต์จริง
              if (isBoldFromName(fontName, fontFamily)) span.classList.add('bold');
              if (isItalicFromName(fontName, fontFamily)) span.classList.add('italic');

              // 2) ถ้าเป็นตระกูล Sarabun/Saraban และมี hint ว่าเป็น Bold ใน family/name → หนาแน่นอน
              if (SARABUN_FAMILY_RE.test(fontName) || SARABUN_FAMILY_RE.test(fontFamily)) {
                if (BOLD_HINTS_RE.test(fontName) || BOLD_HINTS_RE.test(fontFamily)) {
                  span.classList.add('bold');
                }
              }

              // 3) หนาอัตโนมัติสำหรับหัวข้อใหญ่
              if (fontSize >= AUTO_BOLD_1 || fontSize >= AUTO_BOLD_2) {
                span.classList.add('bold');
              }

              // ช่องว่างนำหน้า (ตามตำแหน่งจริง) + บังคับวรรคหลัง bullet/เลขลำดับ
              const prefixSpace = needsSpace(prev, seg) ? ' ' : '';
              const forceTrail = forceTrailingSpaceIfListToken(raw) ? ' ' : '';

              span.innerHTML = esc(prefixSpace + raw + forceTrail);
              lineEl.appendChild(span);

              prev = seg;
            }

            contentEl.appendChild(lineEl);
          }

          if (p < pdf.numPages) {
            const div = document.createElement('div');
            div.className = 'divider';
            contentEl.appendChild(div);
          }
        }

        if (!contentEl.textContent.trim()) {
          contentEl.innerHTML = '<div class="error">พบว่าไฟล์หน้า/ทั้งหมดไม่มีเลเยอร์ข้อความ (เป็นภาพสแกน) — หากต้องการข้อความ ให้ใช้ไฟล์ที่เป็นข้อความ หรือเพิ่ม OCR</div>';
        }
      } catch (err) {
        console.error(err);
        contentEl.innerHTML = '<div class="error">Error: โหลดข้อความจาก PDF ไม่ได้</div>';
      }
    }

    renderTextContinuous(PDF_PATH);
  </script>
</body>
</html>