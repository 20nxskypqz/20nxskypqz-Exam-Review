<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>20nxskypqz Exam Review</title>

  <!-- Google Font: Niramit -->
  <link href="https://fonts.googleapis.com/css2?family=Niramit:wght@400;700&display=swap" rel="stylesheet">

  <style>
    :root { --bg:#f9f9f9; --card:#fff; --shadow:0 6px 24px rgba(0,0,0,.08); --ink:#111; }
    * { box-sizing:border-box; }
    body {
      margin:0; background:var(--bg); color:var(--ink);
      font-family:'Niramit',system-ui,-apple-system,Segoe UI,Arial,sans-serif;
      line-height:1.8; padding:20px;
    }
    h1,h2 { text-align:center; margin:0 0 10px 0; font-weight:700; }
    .docTitle { text-align:center; font-weight:700; margin:16px auto 8px; font-size:22px; }
    .status { text-align:center; font-size:14px; opacity:.75; margin:10px 0; }
    #content {
      max-width:960px; margin:12px auto 24px; background:var(--card); border-radius:12px; box-shadow:var(--shadow);
      padding:20px; white-space:normal; font-size:18px;
    }
    .line { display:block; }
    .chunk { display:inline; }
    .bold { font-weight:700 !important; }
    .italic { font-style:italic; }
    .divider { height:12px; }
    .error { color:#c00; text-align:center; font-weight:700; margin-top:16px; }
  </style>
</head>
<body>
  <h1>Welcome to</h1>
  <h2>20nxskypqz Exam Review</h2>
  <div class="docTitle">สังคมศึกษา ม.4_1-68</div>
  <div class="status" id="status">Loading…</div>

  <div id="content">Loading text from PDF…</div>

  <script type="module">
    import * as pdfjsLib from 'https://unpkg.com/pdfjs-dist@4.4.168/build/pdf.mjs';
    import 'https://unpkg.com/pdfjs-dist@4.4.168/build/pdf.worker.mjs';
    // Tesseract.js (OCR) - ใช้จาก CDN
    import 'https://unpkg.com/tesseract.js@5/dist/tesseract.min.js';

    const PDF_PATH = 'files/สังคมศึกษาทุกเรื่องม.4_1-68.pdf';
    const Y_TOL = 3.0;          // รวมชิ้นข้อความให้เป็นบรรทัดถ้า y ใกล้กัน
    const AUTO_BOLD_1 = 25;     // ทำหนาอัตโนมัติจากขนาด (โหมด text layer)
    const AUTO_BOLD_2 = 20;

    const contentEl = document.getElementById('content');
    const statusEl  = document.getElementById('status');

    const BOLD_RE   = /(bold|black|heavy|demi|semi[-\s]?bold|semibold|demibold|bd|700|800|900)/i;
    const ITALIC_RE = /(italic|oblique|it|slanted)/i;
    const SARABUN_RE = /(sarabun|saraban|thsarabun|sarabunpsk|thsarabunnew)/i;

    const esc = s => s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');

    // -------- Utilities for text-layer path --------
    function groupIntoLines(items){
      const lines=[]; const used = new Array(items.length).fill(false);
      const arr = items.map((item,idx)=>{
        const t=item.transform||[1,0,0,1,0,0];
        const fs=Math.max(Math.abs(t[0]||0),Math.abs(t[3]||0))||18;
        const x=t[4]||0, y=t[5]||0;
        const w=item.width||0;
        return {idx,item,x,y,w,fontSize:fs};
      });
      arr.sort((a,b)=>b.y-a.y);
      for(let i=0;i<arr.length;i++){
        if(used[i]) continue;
        const base=arr[i]; used[i]=true;
        const line=[base];
        for(let j=i+1;j<arr.length;j++){
          if(used[j]) continue;
          const cand=arr[j];
          if(Math.abs(cand.y-base.y)<=Y_TOL){ used[j]=true; line.push(cand); }
        }
        line.sort((a,b)=>a.x-b.x);
        lines.push(line);
      }
      lines.sort((A,B)=>B[0].y-A[0].y);
      return lines;
    }
    function needsSpace(prev,curr){
      if(!prev) return false;
      const prevEnd=prev.x+(prev.w||0);
      const gap=curr.x-prevEnd;
      const th=Math.max(2, prev.fontSize*0.25);
      return gap>th;
    }
    function forceTrailSpaceToken(txt){
      if(txt==='•') return true;
      if(/^\d+\.$/.test(txt)) return true;
      return false;
    }
    function normalizeFontKey(k=''){ const i=k.indexOf('+'); return i>-1?k.slice(i+1):k; }

    function decideBoldItalic(fontNameRaw, family, fontSize){
      const nameNorm = normalizeFontKey(fontNameRaw).toLowerCase();
      const familyLC = (family||'').toLowerCase();
      let isBold = BOLD_RE.test(nameNorm) || BOLD_RE.test(familyLC);
      let isItalic = ITALIC_RE.test(nameNorm) || ITALIC_RE.test(familyLC);
      if (SARABUN_RE.test(nameNorm) || SARABUN_RE.test(familyLC)) {
        if (BOLD_RE.test(nameNorm) || BOLD_RE.test(familyLC)) isBold = true;
      }
      if (fontSize >= AUTO_BOLD_1 || fontSize >= AUTO_BOLD_2) isBold = true;
      return { isBold, isItalic };
    }

    // -------- OCR helpers --------
    async function ocrPageToLines(page, scale=2){
      // render pdf page to canvas (ภาพ) เพื่อ OCR
      const viewport = await page.getViewport({ scale });
      const canvas = document.createElement('canvas');
      canvas.width  = Math.ceil(viewport.width);
      canvas.height = Math.ceil(viewport.height);
      const ctx = canvas.getContext('2d', { alpha:false });
      await page.render({ canvasContext: ctx, viewport }).promise;

      // ใช้ Tesseract (tha+eng)
      statusEl.textContent = `OCR processing… (this page)`;
      const result = await Tesseract.recognize(
        canvas,
        'tha+eng',
        {
          // ดาวน์โหลด traineddata จาก CDN กลาง
          langPath: 'https://tessdata.projectnaptha.com/4.0.0',
          logger: m => { if (m.status) statusEl.textContent = `OCR: ${m.status} ${Math.round((m.progress||0)*100)}%`; }
        }
      );

      // สร้าง “บรรทัด” จาก result.data.lines (คงลำดับบน→ล่าง)
      // ประมาณขนาดอักษรจากความสูง bbox ของบรรทัด
      const lines = (result.data.lines||[]).map(L => {
        const text = (L.text || '').trim();
        const height = Math.abs(L.bbox.y1 - L.bbox.y0) || 18;
        return { text, height };
      }).filter(l => l.text);

      return lines;
    }

    function renderOcrLines(allLines){
      // คำนวณค่าเฉลี่ยความสูงบรรทัดเพื่อเดาหัวข้อ
      const heights = allLines.map(l => l.height);
      const avg = heights.reduce((a,b)=>a+b,0)/(heights.length||1);
      const h1 = avg*1.45; // ใหญ่กว่าค่าเฉลี่ยมาก = หัวข้อใหญ่
      const h2 = avg*1.25; // ใหญ่กว่าค่าเฉลี่ยพอควร = หัวข้อรอง

      contentEl.innerHTML = '';
      for (const L of allLines){
        const div = document.createElement('div');
        div.className = 'line';

        // ตัดคำบางกรณี เพื่อคงเว้นวรรคหลัง bullet/เลขลำดับ
        let txt = L.text;
        // แยกคำต้นบรรทัดเพื่อเติม space หลัง token
        txt = txt.replace(/^(\d+\.)\s?/, (_,m)=> m+' ');
        txt = txt.replace(/^•\s?/, '• ');

        // map ความสูงบรรทัดเป็นขนาดฟอนต์ (ช่วง 16–28px)
        const size = Math.max(16, Math.min(28, (L.height/avg)*18));
        const span = document.createElement('span');
        span.className = 'chunk';
        span.style.fontSize = `${size}px`;
        // ถ้าเป็นหัวข้อ (ใหญ่กว่าเกณฑ์) → หนาอัตโนมัติ
        if (L.height >= h1 || L.height >= h2) span.classList.add('bold');

        span.textContent = txt;
        div.appendChild(span);
        contentEl.appendChild(div);
      }
    }

    // -------- Main pipeline --------
    async function run() {
      try{
        statusEl.textContent = 'Loading PDF…';
        const pdf = await pdfjsLib.getDocument(PDF_PATH).promise;

        // PASS 1: พยายามดึงจาก text layer ก่อน
        statusEl.textContent = 'Extracting text layer…';
        let totalTextCount = 0;
        const pagesForText = [];
        for (let p=1; p<=pdf.numPages; p++){
          const page = await pdf.getPage(p);
          const tc = await page.getTextContent();
          pagesForText.push({ page, tc });
          totalTextCount += (tc.items||[]).length;
        }

        if (totalTextCount > 0){
          // มี text layer → เรนเดอร์ตามพิกัด + รักษารูปแบบ
          contentEl.innerHTML = '';
          statusEl.textContent = `Rendering styled text (${pdf.numPages} pages)…`;

          for (let i=0; i<pagesForText.length; i++){
            const { page, tc } = pagesForText[i];
            const styles = tc.styles || {};
            const lines = groupIntoLines(tc.items||[]);

            for (const line of lines){
              const lineEl = document.createElement('div');
              lineEl.className = 'line';

              let prev=null;
              for(const seg of line){
                const {item,x,y,w,fontSize} = seg;
                const raw=(item.str||'').trim();
                if(!raw){ prev=seg; continue; }

                const span=document.createElement('span');
                span.className='chunk';
                span.style.fontSize=`${fontSize}px`;

                const fontName = item.fontName || '';
                const family = styles[fontName]?.fontFamily || '';
                const flags = decideBoldItalic(fontName, family, fontSize);
                if (flags.isBold) span.classList.add('bold');
                if (flags.isItalic) span.classList.add('italic');

                const prefix = needsSpace(prev,seg) ? ' ' : '';
                const trail = forceTrailSpaceToken(raw) ? ' ' : '';
                span.innerHTML = esc(prefix + raw + trail);
                lineEl.appendChild(span);

                prev=seg;
              }
              contentEl.appendChild(lineEl);
            }
            if (i < pagesForText.length-1){
              const d=document.createElement('div'); d.className='divider'; contentEl.appendChild(d);
            }
          }
          statusEl.textContent = 'Done.';
          return;
        }

        // PASS 2: ไม่มี text layer → ใช้ OCR อัตโนมัติ
        statusEl.textContent = 'No text layer found. Switching to OCR…';
        let allLines = [];
        for (let p=1; p<=pdf.numPages; p++){
          const page = await pdf.getPage(p);
          statusEl.textContent = `OCR page ${p}/${pdf.numPages}…`;
          const lines = await ocrPageToLines(page, 2);  // scale 2x เพื่อความชัด
          allLines = allLines.concat(lines);
        }
        statusEl.textContent = 'Rendering OCR result…';
        renderOcrLines(allLines);
        statusEl.textContent = 'Done (OCR).';
      }catch(err){
        console.error(err);
        contentEl.innerHTML = '<div class="error">Error: โหลด/ประมวลผล PDF ไม่ได้</div>';
        statusEl.textContent = 'Error.';
      }
    }

    run();
  </script>
</body>
</html>